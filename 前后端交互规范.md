前后端交互规范
===================


### REST API基本形态
----------------------------------------

	method:
	GET / POST / PUT / DELETE / extention method....
	// 基本请求方法，分为GET/POST/PUT/DELETE四种；
	// 之外还有扩展方法，只要和基本方法不冲突可自行定义，表示形式为：POST-login；
	// 表现形式为querystring中的 _method 参数(如下)
	
	content type:json or others // 请求发送的数据格式

	http(s)://../{auth/login}.{json}                 ?{_method=login}
	              URI          request content type    query string

    请求连接规范如上，主要分为URI(或者是URL，如果为绝对路径，带http(s)://头则为URL，否则为URI)部分；
	// request content type部分，该部分明确了要求返回数据的格式；
	// querystring部分，该部分用来传递显性参数。

	postdata:{.....}
	// 
	
	
	// 如果为自定义方法，则发起的基本请求方法必须为POST，然后在querystring部分加入_method=method1来指明自定义方法


### REST API 请求码规范
---------------------------------------------------

错误码规范中主要说一下两种HTTP请求码：200 & 500 

##### HTTP 200

无任何错误信息，正常返回数据；

##### HTTP 500

服务器端错误；包含服务器端已知错误和未知错误。

1. 已知错误；本类错误一般为客户端录入的数据不符合规范造成的，比如填写的出售比特币的量超过了账户余额、用户名密码错误...等等
2. 未知错误；本类错误一般为服务器端没有预期到的错误，比如无法连接数据库、磁盘已满...等等

##### 错误码规范

如果请求返回了HTTP500错误，则要求必须根据请求返回信息类型(request content type)返回相应的格式的错误信息。

下面举例一个登录错误说明：

请求信息：
	
	method:POST-login,
	content type:json // 此处为发起请求的时候向后台传送的数据类型
	
	https://domain:port/auth.json?_method=login
	
	POST DATA:
		{u:'zhangsan@xx.com',pw:'123456'}


本例中，客户端发起了一个自定义方法POST-login请求，地址为：`https://domain:port/auth` ，发送的数据格式为json格式，数据为：`{u:'zhangsan@xx.com',pw:'123456'}`；要求返回的数据格式为json(这里由uri后的`.json`明确)


服务器端错误（用户名密码错误）处理方式：

1. 返回HTTP 状态码 500
2. 返回错误数据：

		{
			code:"peatio.invalid_uid_or_password", // 错误码
			message:"用户名或者密码错误" // 错误信息
		}
	
	这里，错误数据中的"code"具有“唯一”、“具有完整信息表述能力”的特点；唯一很容易理解，但是什么是“具有完整信息表述能力”呢？简单的说就是：如果不看"message"中的内容，就能知道该错误代表了什么的能力；这个和纯数字的错误码有本质上的区别；

	"message"中的内容就容易理解了，就是对code的翻译；不过，message在服务器端涉及到一个“国际化”的问题，这里不讲，以后会详细些一个文档说明。


##### 错误码的重要性

本节之所以单独拿出来说一下，是因为这里涉及到一个前端行为的问题；简单的说，就是前端要根据特定的错误码来出发一些特定的动作。

还继续以上面的例子说明：

现在，前端在得到了服务器端的错误信息后，如何处理就成为了需要关注的问题，在上例中，对于“用户名密码错误”这个信息，前端一般的应对方法为：清空表单的内容，并提醒用户重新录入。

那么，这里错误码就有了用武之地，我们只需要判断下code如果是"peatio.invalid_uid_or_password"，则清空表单内容，并提醒用户：“用户名或者密码错误，请重新输入”即可。

### 小结
-------------------------------------------

综合上面的信息，可以发现，本文档中所定的所有规范的最终目的就是彻底的前后端分离，通过规范的定义，解耦前后端代码，以及尽量的降低前后端开发人员工作的重合度。